{
  "version": 3,
  "file": "stateQueueManager.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/core/state/stateQueueManager.ts"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "/** @module state */ /** for typedoc */\nimport { inArray } from '../common/common';\nimport { isString } from '../common/predicates';\nimport { StateDeclaration, _StateDeclaration } from './interface';\nimport { StateObject } from './stateObject';\nimport { StateBuilder } from './stateBuilder';\nimport { StateRegistryListener, StateRegistry } from './stateRegistry';\nimport { Disposable } from '../interface';\nimport { UrlRouter } from '../url/urlRouter';\nimport { prop } from '../common/hof';\nimport { StateMatcher } from './stateMatcher';\n\n/** @internalapi */\nexport class StateQueueManager implements Disposable {\n  queue: StateObject[];\n  matcher: StateMatcher;\n\n  constructor(\n    private $registry: StateRegistry,\n    private $urlRouter: UrlRouter,\n    public states: { [key: string]: StateObject },\n    public builder: StateBuilder,\n    public listeners: StateRegistryListener[],\n  ) {\n    this.queue = [];\n    this.matcher = $registry.matcher;\n  }\n\n  /** @internalapi */\n  dispose() {\n    this.queue = [];\n  }\n\n  register(stateDecl: _StateDeclaration) {\n    const queue = this.queue;\n    const state = StateObject.create(stateDecl);\n    const name = state.name;\n\n    if (!isString(name)) throw new Error('State must have a valid name');\n    if (this.states.hasOwnProperty(name) || inArray(queue.map(prop('name')), name))\n      throw new Error(`State '${name}' is already defined`);\n\n    queue.push(state);\n    this.flush();\n\n    return state;\n  }\n\n  flush() {\n    const { queue, states, builder } = this;\n    const registered: StateObject[] = [], // states that got registered\n      orphans: StateObject[] = [], // states that don't yet have a parent registered\n      previousQueueLength = {}; // keep track of how long the queue when an orphan was first encountered\n    const getState = name => this.states.hasOwnProperty(name) && this.states[name];\n    const notifyListeners = () => {\n      if (registered.length) {\n        this.listeners.forEach(listener => listener('registered', registered.map(s => s.self)));\n      }\n    };\n\n    while (queue.length > 0) {\n      const state: StateObject = queue.shift();\n      const name = state.name;\n      const result: StateObject = builder.build(state);\n      const orphanIdx: number = orphans.indexOf(state);\n\n      if (result) {\n        const existingState = getState(name);\n        if (existingState && existingState.name === name) {\n          throw new Error(`State '${name}' is already defined`);\n        }\n\n        const existingFutureState = getState(name + '.**');\n        if (existingFutureState) {\n          // Remove future state of the same name\n          this.$registry.deregister(existingFutureState);\n        }\n\n        states[name] = state;\n        this.attachRoute(state);\n        if (orphanIdx >= 0) orphans.splice(orphanIdx, 1);\n        registered.push(state);\n        continue;\n      }\n\n      const prev = previousQueueLength[name];\n      previousQueueLength[name] = queue.length;\n      if (orphanIdx >= 0 && prev === queue.length) {\n        // Wait until two consecutive iterations where no additional states were dequeued successfully.\n        // throw new Error(`Cannot register orphaned state '${name}'`);\n        queue.push(state);\n        notifyListeners();\n        return states;\n      } else if (orphanIdx < 0) {\n        orphans.push(state);\n      }\n\n      queue.push(state);\n    }\n\n    notifyListeners();\n    return states;\n  }\n\n  attachRoute(state: StateObject) {\n    if (state.abstract || !state.url) return;\n\n    this.$urlRouter.rule(this.$urlRouter.urlRuleFactory.create(state));\n  }\n}\n"
  ]
}